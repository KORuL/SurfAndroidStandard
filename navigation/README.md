[Главная страница репозитория](/docs/main.md)

# Navigation

## Предпосылки появления

Разработанная в самом начале навигация через навигаторы показала себя несосотоятельной
в сложных сценариях использования: она хорошо решала пробалемы типового приложения с разделением на
фичи-activity, однако при попытке каким-то образом расширить и кастомизировать этот подход, разработчики
сталкивались с необходимостью долгой кастомизации и множеством доработок.

## Проблемы, которые решает модуль navigation.

1. Не унифицированная работа с навигацией для dialogs, fragments и activity.
Запуск этих экранов выглядит совершенно по-разному и в android framework, и в предыдущих разработках Surf.
Модуль navigation решает эту проблему и приводит всю работу с экранами к единой системе: навигации на основе команд.
1. Сложность при организации Single-Activity приложений.
В предыдущей реализации навигации для Fragments,
у разработчиков была возможность опуститься только на один уровень вглубь стека фрагментов
(можно было использовать FragmentNavigator для операций с supportFragmentManager,
и ChildFragmentNavigator для операций с childFragmentManager).
Операции с табами (TabFragmentNavigator) поддерживались только на уровне supportFragmentManager.
Эта проблема решается в модуле navigation гибким запуском команд навигации:
добавлена возможность углубиться на любой уровень вложенности фрагментов, и переключаться между этими уровнями.
1. Асинхронность навигации.
Все команды этого модуля выполняются последовательно и условно-синхронно, что позволяет вызывать цепочки команд
не опасаясь за то, что предыдущий экран еще не будет готов.
1. Излишнее количество реализаций Route. В старом подходе навигации у Route огромное количество
реализаций, многие из которых зависят от того.

## Общий принцип работы.

Принцип работы модуля заключается в следующем:

1. У каждого экрана есть точка входа: Route. Она содержит все входные данные, необходимые для запуска экрана,
однозначно идентифицирует экран на основе этих параметров.
1. Для каждого типа экрана существуют навигаторы (Activity, Fragment, Dialog, Widget),
позволяющие выполнить запуск, закрытие и другие действия с экраном, основываясь на route.
Навигаторы живут в скоупе экрана, умирают и пересоздаются вместе с ним.
Если навигаторы содержат бекстек, он сохраняется и восстанавливается при смене конфигурации.
1. Любое действие, производимое над экраном, заключается в класс Command. Команда содержит в себе Route,
возможные анимации Animations, и другие опции для открытия экрана.
1. Для того, чтобы направлять команды в нужные навигаторы, существуют CommandExecutor-сущности.
У каждого типа экрана есть свой Executor, и он ограничен пулом команд экрана, которые в него поступают.
Все Executor'ы - это синглтоны, и живут столько же, сколько живет приложение.
1. Все Executor'ы объединяются в один, общий Executor,
который распределяет команды между ними и обеспечивает последовательное выполнение.

Таким образом, для открытия activity A нам потребуется:
1. Создать RouteA, которая будет содержать все параметры, необходимые для инициализации и идентификации экрана.
Унаследовать эту Route от ActivityRoute.
    * Переопределить getScreenClass, если route лежит в одном модуле с экраном
    * Переопределить getScreenClassPath, если route лежит в другом модуле, и не имеет прямого доступа к экрану
1. Вызвать метод NavigationCommandExecutor.execute и передать в него команду Start(routeA).


## Сохранение состояния и dependency injection

Данный модуль не привязан к стандартным скоупам core-ui, и не имеет зависимостей от DI-фреймворков.
Сохранение состояния и привязка переменных к определенным экранам здесь реализована
через ActivityLifecycleCallbacks и FragmentLifecycleCallbacks.

Все необходимые для Activity-навигации классы создаются в провайдерах: ActivityNavigationProvider,
и его реализации ActivityNavigationProviderCallbacks.
Здесь для каждой Activity в onCreate создаются ActivityNavigator, DialogNavigator, а также меняется активный в данный момент навигатор в зависимости от того,
какая Activity в данный момент находится в состоянии Resumed.

Все необходимые для Fragment-навигации классы создаются в провайдерах: FragmentNavigationProvider,
и его реализации FragmentNavigationProviderCallbacks.
Здесь для Fragment в onFragmentCreated создаются FragmentNavigator и TabFragmentNavigator,
и происходит переключение между ними: извлечение нужного навигатора происходит по тегу фрагмента, с которым он ассоциирован.

Внимание! Fragment будет содержать навигаторы, только если он наследуется от FragmentNavigationContainer,
то есть, в нем есть ViewGroup, внутри которого будут помещены дочерние фрагменты.

Извлечение нужного навигатора производится через FragmentNavigationProvider.provide(sourceTag).
SourceTag здесь - это тег фрагмента, который содержит навигацию.
В механизме навигации через CommandExecutor, этот тег предоставляется через FragmentCommand.sourceTag.
Если необходимо явно вызвать навигатор из Activity (SupportFragmentManager), в качестве SourceTag может быть передан
ACTIVITY_NAVIGATION_TAG.

Для того, чтобы постоянно не указывать sourceTag, существует ScreenCommandExecutor,
который действует на основе FragmentProvider, извлекает фрагмент из текущего Dagger-скоупа, и снабжает им команду.