[Главная страница репозитория](/docs/main.md)

# Navigation

## Предпосылки появления

Разработанная в самом начале навигация через навигаторы показала себя несосотоятельной
в сложных сценариях использования: она хорошо решала проалемы типового приложения с разделением на
фичи-activity, однако при попытках расширить и кастомизировать этот подход, разработчики
сталкивались с необходимостью полной переработки навигаторов на собственных проектах.

## Проблемы, которые решает модуль navigation.

1. Нет единообразия при работе с навигацией для Activity, Fragment и Dialog.
Запуск этих экранов выглядит совершенно по-разному и в android framework, и в предыдущих разработках Surf.
Модуль navigation решает эту проблему и приводит всю работу с экранами к единой системе: навигации на основе команд.
1. Сложность при организации Single-Activity приложений.
В предыдущей реализации навигации для Fragments,
у разработчиков была возможность опуститься только на один уровень вглубь стека фрагментов
(можно было использовать FragmentNavigator для операций с supportFragmentManager,
и ChildFragmentNavigator для операций с childFragmentManager).
Операции с табами (TabFragmentNavigator) поддерживались только на уровне supportFragmentManager.
Эта проблема решается в модуле navigation гибким запуском команд навигации:
добавлена возможность углубиться на любой уровень вложенности фрагментов, и переключаться между этими уровнями.
1. Асинхронность навигации.
Все команды этого модуля выполняются последовательно и условно-синхронно, что позволяет вызывать цепочки команд
не опасаясь за то, что предыдущий экран еще не будет готов.
1. Излишнее количество реализаций Route. В старом подходе навигации у Route огромное количество
реализаций, многие из которых просто не нужны, и заставляют пользователя путаться при выборе.
В текущей реализации базовых Route есть всего несколько, и они разделены по типам экранов: Activity, Fragment, Dialog и Widget.

## Общий принцип работы.

Принцип работы модуля заключается в следующем:

1. У каждого экрана есть точка входа: Route. Она содержит все входные данные, необходимые для запуска экрана,
однозначно идентифицирует экран на основе этих параметров.
1. Для каждого типа экрана существуют навигаторы (Activity, Fragment, Dialog, Widget),
позволяющие выполнить запуск, закрытие и другие действия с экраном, основываясь на route.
Навигаторы живут в скоупе экрана, умирают и пересоздаются вместе с ним.
Если навигаторы содержат бекстек, он сохраняется и восстанавливается при смене конфигурации.
1. Любое действие, производимое над экраном, заключается в класс Command. Команда содержит в себе Route,
возможные анимации Animations, и другие опции для открытия экрана.
1. Для того, чтобы направлять команды в нужные навигаторы, существуют CommandExecutor-сущности.
У каждого типа экрана есть свой Executor, и он ограничен пулом команд экрана, которые в него поступают.
Все Executor'ы - это синглтоны, и живут столько же, сколько живет приложение.
1. Все Executor'ы объединяются в один, общий Executor,
который распределяет команды между ними и обеспечивает последовательное выполнение.


## Сохранение состояния и dependency injection

Данный модуль не привязан к стандартным скоупам core-ui, и не имеет зависимостей от DI-фреймворков.
Сохранение состояния и привязка переменных к определенным экранам здесь реализована
через ActivityLifecycleCallbacks и FragmentLifecycleCallbacks.

Все необходимые для Activity-навигации классы создаются в провайдерах: ActivityNavigationProvider,
и его реализации ActivityNavigationProviderCallbacks.
Здесь для каждой Activity в onCreate создаются ActivityNavigator, DialogNavigator, а также меняется активный в данный момент навигатор в зависимости от того,
какая Activity в данный момент находится в состоянии Resumed.

Все необходимые для Fragment-навигации классы создаются в провайдерах: FragmentNavigationProvider,
и его реализации FragmentNavigationProviderCallbacks.
Здесь для Fragment в onFragmentCreated создаются FragmentNavigator и TabFragmentNavigator,
и происходит переключение между ними: извлечение нужного навигатора происходит по тегу фрагмента, с которым он ассоциирован.

Внимание! Fragment будет содержать навигаторы, только если он наследуется от FragmentNavigationContainer,
то есть, в нем есть ViewGroup, внутри которого будут помещены дочерние фрагменты.

Извлечение нужного навигатора производится через FragmentNavigationProvider.provide(sourceTag).
SourceTag здесь - это тег фрагмента, который содержит навигацию.
В механизме навигации через CommandExecutor, этот тег предоставляется через FragmentCommand.sourceTag.
Если необходимо явно вызвать навигатор из Activity (SupportFragmentManager), в качестве SourceTag может быть передан
ACTIVITY_NAVIGATION_TAG.

Для того, чтобы постоянно не указывать sourceTag, существует ScreenScopeCommandExecutor,
который действует на основе FragmentProvider, извлекает фрагмент из текущего Dagger-скоупа, и снабжает им команду.

## Анимации

Для того, чтобы осуществить какую-либо команду с анимацией, необходимо передать в параметр Animations
вашу анимацию, которую сможет обработать навигатор.
Стандартные навигаторы поддерживают обработку [BaseResourceAnimations], [SharedElementAnimations] и
[SetAnimations], в котором могут быть первые 2.

Для того, чтобы применить одну базовую анимацию сразу для всех команд всего приложения,
вы можете переопределить значения из класса DefaultAnimations. В нем содержатся анимации по-умолчанию
для каждого типа экрана.

## Подключение

Gradle:
```
    implementation "ru.surfstudio.android:navigation:X.X.X"
```

## Инициализация компонентов

Для того, чтобы команды навигации выполнялись и обрабатывались, вам нужно
инициализировать CommandExecutor в Application-классе вашего приложения:

1. Создайте ActivityNavigationProvider. Вы можете использовать свою реализацию, либо готовый
ActivityNavigationProviderCallbacks.
Во втором случае, не забудьте зарегистрировать коллбеки в Application.

1. Если вы используете модуль [navigation-observer](lib-navigation-observer), инициализируйте ScreenResultBus.
Для него потребуется хранилище ScreenResultStorage, можете использовать FileScreenResultStorage с директорией
noBackupFilesDir.

1. Создайте AppCommandExecutor: если вы используете модуль navigation-observer, это будет
`AppCommandExecutorWithResult(screenResultBus, activityNavigationProvider)`, иначе -
`AppCommandExecutor(activityNavigationProvider)`.

1. Полученный CommandExecutor вы можете поместить в статическую переменную (если не используете DI),
либо предоставить как singletone-зависимость в вашем DI-фреймворке.

Для примера инициализации без какого-либо DI-фреймворка, вы можете посмотреть на
реализацию класса App из [Navigation sample](sample-core-mvp).

Для примера инициализации с использованием Dagger 2, вы можете посмотреть на
реализаци класса App из [Navigation Surf sample](sample-standard).

## Использование

### Открытие экрана (Activity)

Для открытия activity A нам потребуется:
1. Создать RouteA, которая будет содержать все параметры, необходимые для инициализации и идентификации экрана.
Унаследовать эту Route от ActivityRoute.
    * Переопределить getScreenClass, если route лежит в одном модуле с экраном
    * Переопределить getScreenClassPath, если route лежит в другом модуле, и не имеет прямого доступа к экрану
1. Вызвать метод NavigationCommandExecutor.execute и передать в него команду Start(routeA).

### Открытие экрана (Dialog)

Осуществляется аналогично открытию Activity, только route наследуется от DialogRoute,
и вместо команды Start используется команда Show.

### Открытие экрана (Fragment)

Для открытия fragmentA нам потребуется:
1. Создать RouteA, которая будет содержать все параметры, необходимые для инициализации и идентификации экрана.
Унаследовать эту Route от FragmentRoute.
    * Переопределить getScreenClass, если route лежит в одном модуле с экраном
    * Переопределить getScreenClassPath, если route лежит в другом модуле, и не имеет прямого доступа к экрану
1. Унаследовать класс-родитель, содержащий ViewGroup-контейнер для отображения фрагмента, от
интерфейса  FragmentNavigationContainer и задать полю `containerId` значение с id этой ViewGroup.
1. Извлечь тег экрана, открывающего этот Fragment (route.getTag / fragment.getTag).
    * Если экран открывает activity, этот шаг можно опустить.
    * Если в качестве NavigationCommandExecutor вы используете ScreenScopeCommandExecutor, этот шаг можно опустить.
1. Вызвать метод NavigationCommandExecutor.execute и передать в него команду Add(routeA, sourceTag),
где routeA - route, созданный на первом шаге, sourceTag - тег экрана, созданный на 3 шаге.
